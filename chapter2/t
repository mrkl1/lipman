Чтобы задать кодировку текста можно писать так
//L"text" - wchar_t
//u8"text" - utf8
//U"text" unicode16/32


Инициализаци в с++ это не присвоение
инициализация переменной происходит
при ее создании. Присовение удаляет текущее
значение объекта и заменяет его новым

   int ex = 0;
   //это называют списочной инициализацией
   //

   int ex1 = {0};
   int ex2 {0};
   int ex3 (0);
   int ex4 = (0);

также ввели инициализацию по умолчанию
пустая строка или ноль и тд. каждое значение
для своего объекта.
но все равно некоторые классы требуют явной инициализации
и компилятор может жаловаться на это

раздельная компиляция (separate compilation)
https://www.cyberforum.ru/cpp-beginners/thread1783229.html

Соглашения об именах

имена переменных должны быть строчными
index
Имена классов с прописной
Sales_item
несколько слов разделяют через _ или слитно но с большой
 буквы новое слово

//ссылки
   int newVal = 1;
    int &ref = newVal;
//
 при создании ссылки вместо копирования используется
 bind (связывание), ссылку нужно инициализировать при
 объявлении, она будет связана с исходным объектом
Ссылка это не объект а другое имя существующего объекта


*****
Указатели, в отличии от ссылок это  объект
указатель содержит адрес другого объекта
И в отличии от ссылки может указывать на множество
разных объектов за время своей жизни


для получения адреса используется оператор обращения
к адресу (address-of operator) - &

4 состояния значения (адреса) в указателе
1) Оно может указывать на объект
2) МОжет указывать на область за концом объекта
3) может быть нулевое значение, означающее, что данный указатель
    не связан ни с одним объектом
4) Оно может быть недопустимо (любое другое кроме указанных в п 1-3).

//присвоение знаечния указателю
double *p1;
    p1 = &dp;
    *p1 += 33;

p1 - адрес на который указывает указатель
*p - значение хранимое по адресу
&p - адрес указателя
//
если указатель нужно сделать нулевым
то использовать нужно nullptr; а не NULL

использование неинеуиализированного указателя это
попытка попытка доступа к несуществующему объекту
в произвольной области памяти.
Нет никакого способа отличить допустимый
адрес от недопустимого.
Авторы рекомендуют инициализировать все переменные
и все указатели, в крайнем случае указатель можно
инициализировать через nullptr или 0.
 //указатели можно использовать в условии
    //любой отличиный от нуля является true
    //p2!=p1 можно даже сравнивать
    //равны когда они оба nullptr
    //или содержать одинаковый адрес
    if (p2){
        std::cout<<"p2 now is nullptr"<<"\n";
    }
    p2 = p1;

    if (p2){
        std::cout<<"p2 now is "<<p2<<"\n";
    }
//

при объявлении переменной нужно учитывать, что
модификаторы * и & относятся только к переменной
и не относятся к типу, например

int* p1,p2; p1 - указатель, p2 - просто переменная (не указатель)
                //ссылка на указатель выглядит так
    int *ip=0, *&r = ip;
//
Одна из особенностей при объявлении констант
const int bufSize = 512;








